# IsolationTree
高并发系统中的隔离技术

![](https://i.imgur.com/N8WFIQU.png)

<pre>
线程隔离：

          通常是线程池隔离：在实际使用中把请求分类，然后交给不同的线程池处理。
          当一种业务的请求处理发生问题时，不会将故障扩散到其他线程池，从而保证其他服务可用。
</pre>


![](https://i.imgur.com/8p94WqY.png)

<pre>
进程隔离:
           进程隔离通常是把一个大的系统拆分为数个功能独立的子系统
</pre>

![](https://i.imgur.com/rqiCa6n.png)

![](https://i.imgur.com/37k16Og.png)

<pre>
集群隔离
          随着系统的发展，单实例已经不能满足需求了，此时需要服务化技术，通过部署多个服务，
      形成服务集群来提升系统容量。

          随着调用方的增多，当秒杀服务被刷回影响到其他服务的稳定性，此时应该考虑将秒杀服务
      分离开来，提供单独的服务集群。
</pre>

![](https://i.imgur.com/eNbZz8H.png)

<pre>
机房隔离

           随着对系统可用性的要求，会进行多机房部署，每个机房的服务都有自己的服务分组，本
      机房的服务应该只调用本机房服务，不进行跨机房调用；其中一个机房服务发生问题可以通过
      DNS/负载均衡将请求全部切到另一个机房；或者考虑服务能自动重试其他机房的服务从而提高
      西宫可用性。
</pre>

![](https://i.imgur.com/8jQEVFl.png)

<pre>
读写隔离
           通过主从模式将读写集群分离，度服务只从从Redis集群获取数据。
</pre>

![](https://i.imgur.com/oYErDFx.png)

<pre>
动静分离
           将动态内容和静态资源分离，一般应该将静态资源放在CDN上
</pre>

<pre>
热点隔离：
 
           例如：抢购，秒杀系统隔离
</pre>